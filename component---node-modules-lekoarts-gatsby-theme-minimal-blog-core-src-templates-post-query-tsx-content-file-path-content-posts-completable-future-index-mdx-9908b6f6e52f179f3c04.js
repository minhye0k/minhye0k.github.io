"use strict";(self.webpackChunkminimal_blog=self.webpackChunkminimal_blog||[]).push([[878],{4765:function(e,t,n){n.d(t,{F:function(){return s},Z:function(){return E}});var l=n(7294),a=n(8733),r=n(795),o=n(1521),c=n(6799),u=n(8871);var m=e=>{let{post:t}=e;return null};const i=["16px","8px","4px"].map((e=>"rgba(0, 0, 0, 0.1) 0px "+e+" "+e+" 0px"));var p=e=>{let{data:{post:t},children:n}=e;return(0,a.tZ)(o.Z,null,(0,a.tZ)(r.X6,{as:"h1",variant:"styles.h1"},t.title),(0,a.tZ)("p",{sx:{color:"secondary",mt:3,a:{color:"secondary"},fontSize:[1,1,2]}},(0,a.tZ)("time",null,t.date),t.tags&&(0,a.tZ)(l.Fragment,null," — ",(0,a.tZ)(c.Z,{tags:t.tags})),t.timeToRead&&" — ",t.timeToRead&&(0,a.tZ)("span",null,t.timeToRead," min read")),(0,a.tZ)("section",{sx:{my:5,".gatsby-resp-image-wrapper":{my:[4,4,5],borderRadius:"4px",boxShadow:i.join(", "),".gatsby-resp-image-image":{borderRadius:"4px"}},variant:"layout.content"}},n),(0,a.tZ)(m,{post:t}))};const s=e=>{var t,n,l;let{data:{post:r}}=e;return(0,a.tZ)(u.Z,{title:r.title,description:r.description?r.description:r.excerpt,image:r.banner?null===(t=r.banner)||void 0===t||null===(n=t.childImageSharp)||void 0===n||null===(l=n.resize)||void 0===l?void 0:l.src:void 0,pathname:r.slug,canonicalUrl:r.canonicalUrl})};function E(e){let{...t}=e;return l.createElement(p,t)}},6799:function(e,t,n){var l=n(8733),a=n(7294),r=n(1883),o=n(3494),c=n(9706);t.Z=e=>{let{tags:t}=e;const{tagsPath:n,basePath:u}=(0,o.Z)();return(0,l.tZ)(a.Fragment,null,t.map(((e,t)=>(0,l.tZ)(a.Fragment,{key:e.slug},!!t&&", ",(0,l.tZ)(r.Link,{sx:e=>{var t;return{...null===(t=e.styles)||void 0===t?void 0:t.a}},to:(0,c.Z)("/"+u+"/"+n+"/"+e.slug)},e.name)))))}},8871:function(e,t,n){var l=n(7294),a=n(1883),r=n(4232);t.Z=e=>{let{title:t="",description:n="",pathname:o="",image:c="",children:u=null,canonicalUrl:m=""}=e;const i=(0,r.Z)(),{siteTitle:p,siteTitleAlt:s,siteUrl:E,siteDescription:g,siteImage:h,author:d,siteLanguage:b}=i,F={title:t?t+" | "+p:s,description:n||g,url:""+E+(o||""),image:""+E+(c||h)};return l.createElement(l.Fragment,null,l.createElement("html",{lang:b}),l.createElement("title",null,F.title),l.createElement("meta",{name:"description",content:F.description}),l.createElement("meta",{name:"image",content:F.image}),l.createElement("meta",{property:"og:title",content:F.title}),l.createElement("meta",{property:"og:url",content:F.url}),l.createElement("meta",{property:"og:description",content:F.description}),l.createElement("meta",{property:"og:image",content:F.image}),l.createElement("meta",{property:"og:type",content:"website"}),l.createElement("meta",{property:"og:image:alt",content:F.description}),l.createElement("meta",{name:"twitter:card",content:"summary_large_image"}),l.createElement("meta",{name:"twitter:title",content:F.title}),l.createElement("meta",{name:"twitter:url",content:F.url}),l.createElement("meta",{name:"twitter:description",content:F.description}),l.createElement("meta",{name:"twitter:image",content:F.image}),l.createElement("meta",{name:"twitter:image:alt",content:F.description}),l.createElement("meta",{name:"twitter:creator",content:d}),l.createElement("meta",{name:"gatsby-theme",content:"@lekoarts/gatsby-theme-minimal-blog"}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"32x32",href:(0,a.withPrefix)("/favicon-32x32.png")}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"16x16",href:(0,a.withPrefix)("/favicon-16x16.png")}),l.createElement("link",{rel:"apple-touch-icon",sizes:"180x180",href:(0,a.withPrefix)("/apple-touch-icon.png")}),m?l.createElement("link",{rel:"canonical",href:m}):null,u)}},1156:function(e,t,n){n.r(t),n.d(t,{Head:function(){return c.F},default:function(){return u}});var l=n(7294),a=n(1151);function r(e){const t=Object.assign({h2:"h2",hr:"hr",h4:"h4",p:"p",ol:"ol",li:"li",ul:"ul",h3:"h3",code:"code",pre:"pre",strong:"strong",a:"a"},(0,a.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(t.h2,null,"Java 에서 I/O Bound 작업을 병렬화 하는 법"),"\n",l.createElement(t.hr),"\n",l.createElement(t.h4,null,"들어가기에 앞서"),"\n",l.createElement(t.p,null,"미디어 파일에 대한 처리가 필요할 떄가 있다. 예를 들어 동영상의 경우 썸네일을 추출한다거나 여러 화질로 트랜스코딩을 진행해야 한다. 한 번에 여러 개의 동영상에 대한 처리 요구가 들어오게 되면 I/O 작업 때문에 처리 시간이 길어진다. 따라서 이 작업들을 병렬화하여 처리 시간을 줄일 수 있는 Java 의 CompletableFuture 과 적절한 ThreadPool 구성에 대한 개념까지 알아보자."),"\n",l.createElement(t.hr),"\n",l.createElement(t.h4,null,"Our Goal"),"\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"CompletableFuture 의 기본 개념을 이해하고 응용할 수 있다."),"\n",l.createElement(t.li,null,"I/O Bound 작업에 알맞는 Thread Pool 의 구성을 이해하고 설정할 수 있다."),"\n"),"\n",l.createElement(t.hr),"\n",l.createElement(t.h2,null,"구현 과정"),"\n",l.createElement(t.hr),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"\n",l.createElement(t.h3,null,"환경"),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"Spring Boot"),"\n",l.createElement(t.li,null,"FFmpeg"),"\n",l.createElement(t.li,null,"CompletableFuture"),"\n"),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.h3,null,"CompletableFuture 란?"),"\n",l.createElement(t.p,null,"Java8 부터 등장한 비동기 작업을 유연하게 수행할 수 있도록 지원해주는 클래스이다.\n기존에 존재하던 ",l.createElement(t.code,null,"Future")," 의 한계점들을 보완하기 위해 등장했다."),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"블로킹을 통해서만 이후 결과 처리 가능"),"\n",l.createElement(t.li,null,"여러 비동기 작업 조합 불가능"),"\n",l.createElement(t.li,null,"예외 처리 불가능"),"\n"),"\n",l.createElement(t.p,null,"이러한 한계점을 극복한 CopmletableFuture 로 IO Bound 작업을 병렬화하는 과정에 대해 살펴보자."),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.h3,null,"FFmpeg 을 통한 동영상 썸네일 추출 작업"),"\n",l.createElement(t.p,null,"IO Bound 작업으로 동영상 썸네일 추출하는 작업을 선택하였다. 도구는 FFmpeg 을 선택하였고 이를 Spring Boot 에서 쉽게 사용할 수 있도록 FFmpeg Wrapper 라이브러리를 적용해주었다."),"\n",l.createElement(t.pre,null,l.createElement(t.code,null,"implementation 'net.bramp.ffmpeg:ffmpeg:0.8.0'\n")),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"FFmpeg 을 통한 썸네일 추출"),"\n"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-java"},'public Supplier<String> extractThumbnail(String videoPath) throws IOException {\n    ClassPathResource classPathResource = new ClassPathResource("thumbnails");\n    final String path = classPathResource.getURI().getPath();\n\n    return () -> {\n        log.info("starting extracted thumbnail of {}", videoPath);\n        final String thumbnailFilename = UUID.randomUUID().toString();\n\n        FFmpegBuilder fFmpegBuilder = new FFmpegBuilder()\n                .addInput(videoPath)\n                .addExtraArgs("-ss", "00:00:01")\n                .addOutput(path + "/" + thumbnailFilename + ".png")\n                .setFrames(1)\n                .done();\n\n        fFmpegExecutor.createJob(fFmpegBuilder).run();\n\n        return thumbnailFilename;\n    };\n}\n')),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.h3,null,"CompletableFuture 를 이용한 병렬화"),"\n",l.createElement(t.pre,null,l.createElement(t.code,{className:"language-java"},'public List<String> extractThumbnailsInParallel(List<String> videos) throws IOException{\n    List<CompletableFuture<String>> completableFutures = new ArrayList<>();\n\n    for (String video : videos) {\n        CompletableFuture<String> completableFuture = CompletableFuture.supplyAsync(extractThumbnail(video), executor)\n                .exceptionally(\n                        e -> {\n                            log.error("error occurring in extracted thumbnail of {} ", video, e);\n                            return exception;\n                        }\n                );\n        completableFutures.add(completableFuture);\n    }\n    final CompletableFuture<List<String>> completableFuture = CompletableFuture.allOf(completableFutures.toArray(new CompletableFuture[0]))\n            .thenApply(v -> completableFutures.stream()\n                    .map(CompletableFuture::join)\n                    .collect(Collectors.toList())\n            );\n\n    return completableFuture.join();\n}\n')),"\n",l.createElement(t.p,null,l.createElement(t.code,null,"CompletableFuture")," 를 통해 썸네일 추출 작업을 병렬화 한 코드이다. 필자는 Return Value 가 필요한 상황이기 때문에 ",l.createElement(t.code,null,"supplyAsync")," 를 사용하였고, 만약 필요없다면 ",l.createElement(t.code,null,"runAsync")," 를 사용해주면 된다.\n",l.createElement(t.code,null,"CompletableFuture.allOf")," 메서드를 통해 새로운 CompletableFuture 를 생성하고 이를 다시 현재 스레드에 join 하여 Async 로 동작하게 한 작업들이 모두 끝나면 Blocking 으로 결과 값을 받을 수 있다."),"\n",l.createElement(t.p,null,"이때 주의할 점은 ",l.createElement(t.code,null,"exceptionally")," 나 ",l.createElement(t.code,null,"handle")," 메서드를 통해 예외를 제어해주지 않으면 현재 스레드에서 예외가 발생하게 된다."),"\n",l.createElement(t.p,null,"물론 join 없이 Non-Blocking 으로 구현한다면 현재 스레드에서 예외가 발생하지 않지만 비동기 작업이 정상적으로 이루어지지 않는 것에 대한 대비를 해주어야 하기 때문에 예외 처리를 해주어야 한다."),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,"join 과 get 의 차이점","\n",l.createElement(t.ol,null,"\n",l.createElement(t.li,null,"join 은 unchecked exception 을 throw 하고 get 은 checked exception 을 throw 한다."),"\n",l.createElement(t.li,null,"get 은 timeout 을 제어할 수 있다."),"\n",l.createElement(t.li,null,"join 은 interrupt 가 불가능하지만 get 은 가능하다."),"\n"),"\n"),"\n"),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.h3,null,"ForkJoinPool"),"\n",l.createElement(t.p,null,l.createElement(t.strong,null,"ForkJoinPool")," 은 CompletableFutre 에서 default 로 설정되는 thread pool 이다. 이의 특징은 CPU Bound 연산을 수행할 때 ",l.createElement(t.strong,null,"work-stealing 알고리즘"),"을 사용하여\n작업이 밀려있는 다른 thread 의 작업 queue 에서 작업을 가져와 수행하기 때문에 CPU 를 좀 더 효율적으로 사용할 수 있다는 점이다."),"\n",l.createElement(t.p,null,"이를 이용할 때 중요한 점은 가능한 가장 작은 단위로 작업을 분할할수록 work-stealing 알고리즘이 잘 작동하여 효율이 높아진다는 것이다."),"\n",l.createElement(t.p,null,"필자는 ",l.createElement(t.strong,null,"IO Bound 작업"),"이고 해당 작업과 서버 환경에서 세밀하게 ",l.createElement(t.strong,null,"thread pool 옵션"),"들을 설정하기 위해 ",l.createElement(t.code,null,"ThreadPoolExecutor")," 로 적용하였다."),"\n"),"\n",l.createElement(t.li,null,"\n",l.createElement(t.h2,null,"마치며"),"\n",l.createElement(t.p,null,"CompletableFuture 는 본 글에서 소개된 내용 말고도 연산을 여러 단계로 연계하거나 결합할 수 있는 다양한 기능을 가진 메서드들이 많아 유연한 비동기 프로그래밍을 지원한다.\n참고에 잘 정리된 글에 대한 링크를 남겨두었으니 관심있게 보면 좋을 것 같다."),"\n",l.createElement(t.p,null,"또한 thread pool 에 대해 짧게 다루어봤는데 좀 더 깊게 알아보고 성능 테스트까지 해보고 싶어 공부하고 정리해서 포스팅 해 볼 것이다.\n본 포스팅에 사용된 코드는 ",l.createElement(t.a,{href:"https://github.com/minhye0k/blog-code/tree/main/asynchronous"},"여기"),"에서 확인할 수 있다."),"\n"),"\n"),"\n",l.createElement(t.hr),"\n",l.createElement(t.h2,null,"참고"),"\n",l.createElement(t.hr),"\n",l.createElement(t.ul,null,"\n",l.createElement(t.li,null,l.createElement(t.a,{href:"https://11st-tech.github.io/2024/01/04/completablefuture"},"Java CompletableFuture 로 비동기 적용하기")),"\n",l.createElement(t.li,null,l.createElement(t.a,{href:"https://www.baeldung.com/java-fork-join"},"Java fork join")),"\n",l.createElement(t.li,null,l.createElement(t.a,{href:"https://www.baeldung.com/java-completablefuture-join-vs-get"},"https://www.baeldung.com/java-completablefuture-join-vs-get")),"\n",l.createElement(t.li,null,l.createElement(t.a,{href:"https://upcurvewave.tistory.com/653"},"Java 병렬 처리 ForkJoinPool 기본 작동 원리")),"\n"))}var o=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?l.createElement(t,e,l.createElement(r,e)):r(e)},c=n(4765);function u(e){return l.createElement(c.Z,e,l.createElement(o,e))}c.Z}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-completable-future-index-mdx-9908b6f6e52f179f3c04.js.map